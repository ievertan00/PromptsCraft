"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const sqlite3_types_1 = require("./sqlite3-types");
const Statement_1 = tslib_1.__importDefault(require("./Statement"));
class Database {
    constructor(wasm, data) {
        this.wasm = wasm;
        this.filename = `dbfile_${(0xffffffff * Math.random()) >>> 0}`;
        if (typeof data !== 'undefined') {
            this.wasm.FS.createDataFile('/', this.filename, data, true, true);
        }
        this.handleError(this.wasm.sqlite3_open(`${this.filename}`, this.wasm.tempInt32));
        this.dbPtr = this.wasm.getValue(this.wasm.tempInt32, '*');
        this.statements = {};
        this.functions = {};
    }
    run(sql, params) {
        if (!this.dbPtr) {
            throw new Error('Database closed');
        }
        if (params) {
            const stmt = this.prepare(sql, params);
            try {
                stmt.step();
            }
            finally {
                stmt.free();
            }
        }
        else {
            this.handleError(this.wasm.sqlite3_exec(this.dbPtr, sql, 0, 0, this.wasm.tempInt32));
        }
        return this;
    }
    exec(sql) {
        if (!this.dbPtr) {
            throw new Error('Database closed');
        }
        const stack = this.wasm.stackSave();
        try {
            let nextSqlPtr = this.wasm.allocateUTF8OnStack(sql);
            const pzTail = this.wasm.stackAlloc(4);
            const results = [];
            while (this.wasm.getValue(nextSqlPtr, 'i8') !== this.wasm.NULL) {
                this.wasm.setValue(this.wasm.tempInt32, 0, '*');
                this.wasm.setValue(pzTail, 0, '*');
                this.handleError(this.wasm.sqlite3_prepare_v2_sqlptr(this.dbPtr, nextSqlPtr, -1, this.wasm.tempInt32, pzTail));
                const stmtPtr = this.wasm.getValue(this.wasm.tempInt32, '*');
                nextSqlPtr = this.wasm.getValue(pzTail, '*');
                if (stmtPtr === this.wasm.NULL) {
                    break;
                }
                const stmt = new Statement_1.default(stmtPtr, this);
                try {
                    let inserted = false;
                    while (stmt.step()) {
                        if (!inserted) {
                            inserted = true;
                            results.push({
                                columns: stmt.getColumnNames(),
                                values: [],
                            });
                        }
                        results[results.length - 1].values.push(stmt.get());
                    }
                }
                finally {
                    stmt.free();
                }
            }
            return results;
        }
        finally {
            this.wasm.stackRestore(stack);
        }
    }
    each(sql, ...args) {
        let stmt;
        let doneCallback;
        let rowCallback;
        if (typeof args[0] === 'function') {
            stmt = this.prepare(sql);
            rowCallback = args[0];
            doneCallback = args[1];
        }
        else {
            stmt = this.prepare(sql, args[0]);
            rowCallback = args[1];
            doneCallback = args[2];
        }
        if (typeof rowCallback !== 'function') {
            throw new Error('No callback passed');
        }
        try {
            while (stmt.step()) {
                rowCallback(stmt.getAsObject());
            }
        }
        finally {
            stmt.free();
        }
        if (typeof doneCallback === 'function') {
            return doneCallback();
        }
        else {
            return this;
        }
    }
    prepare(sql, params) {
        this.wasm.setValue(this.wasm.tempInt32, 0, '*');
        this.handleError(this.wasm.sqlite3_prepare_v2(this.dbPtr, sql, -1, this.wasm.tempInt32, this.wasm.NULL));
        const stmtPtr = this.wasm.getValue(this.wasm.tempInt32, '*');
        if (stmtPtr === this.wasm.NULL) {
            throw new Error('Nothing to prepare. Check your SQL statement.');
        }
        const stmt = new Statement_1.default(stmtPtr, this);
        if (typeof params !== 'undefined') {
            stmt.bind(params);
        }
        this.statements[stmtPtr] = stmt;
        return stmt;
    }
    _close() {
        for (const [, stmt] of Object.entries(this.statements)) {
            stmt.free();
        }
        this.statements = {};
        for (const [, func] of Object.entries(this.functions)) {
            this.wasm.removeFunction(func);
        }
        this.functions = {};
        this.handleError(this.wasm.sqlite3_close_v2(this.dbPtr));
    }
    export() {
        this._close();
        const binaryDb = this.wasm.FS.readFile(this.filename, { encoding: 'binary' });
        this.handleError(this.wasm.sqlite3_open(this.filename, this.wasm.tempInt32));
        this.dbPtr = this.wasm.getValue(this.wasm.tempInt32, '*');
        return binaryDb;
    }
    close() {
        this._close();
        this.wasm.FS.unlink(`/${this.filename}`);
        this.filename = '';
        this.dbPtr = this.wasm.NULL;
    }
    handleError(returnCode) {
        if (returnCode === sqlite3_types_1.ReturnCode.OK) {
            return true;
        }
        else {
            throw new Error(this.wasm.sqlite3_errmsg(this.dbPtr));
        }
    }
    getRowsModified() {
        return this.wasm.sqlite3_changes(this.dbPtr);
    }
    createFunction(name, func) {
        const wrappedFunc = (sqlite3ContextPtr, argc, argvPtr) => {
            const args = [];
            for (let i = 0; i < argc; i++) {
                const valuePtr = this.wasm.getValue(argvPtr + 4 * i, '*');
                const valueType = this.wasm.sqlite3_value_type(valuePtr);
                const dataFunc = (() => {
                    switch (false) {
                        case valueType !== 1:
                            return this.wasm.sqlite3_value_double;
                        case valueType !== 2:
                            return this.wasm.sqlite3_value_double;
                        case valueType !== 3:
                            return this.wasm.sqlite3_value_text;
                        case valueType !== 4:
                            return function (ptr) {
                                const size = this.wasm.sqlite3_value_bytes(ptr);
                                const blobPtr = this.wasm.sqlite3_value_blob(ptr);
                                const blobArg = new Uint8Array(size);
                                for (let j = 0; j < size; j++) {
                                    blobArg[j] = this.wasm.HEAP8[blobPtr + j];
                                }
                                return blobArg;
                            };
                        default:
                            return function (_) {
                                return null;
                            };
                    }
                })();
                args.push(dataFunc(valuePtr));
            }
            let result;
            try {
                result = func(...args);
            }
            catch (error) {
                this.wasm.sqlite3_result_error(sqlite3ContextPtr, error, -1);
                return;
            }
            switch (typeof result) {
                case 'boolean':
                    this.wasm.sqlite3_result_int(sqlite3ContextPtr, result ? 1 : 0);
                    break;
                case 'number':
                    this.wasm.sqlite3_result_double(sqlite3ContextPtr, result);
                    break;
                case 'string':
                    this.wasm.sqlite3_result_text(sqlite3ContextPtr, result, -1, -1);
                    break;
                case 'object':
                    if (result === null) {
                        this.wasm.sqlite3_result_null(sqlite3ContextPtr);
                    }
                    else if (Array.isArray(result)) {
                        const blobPtr = this.wasm.allocate(result, 'i8', this.wasm.ALLOC_NORMAL);
                        this.wasm.sqlite3_result_blob(sqlite3ContextPtr, blobPtr, result.length, -1);
                        this.wasm._free(blobPtr);
                    }
                    else {
                        this.wasm.sqlite3_result_error(sqlite3ContextPtr, `Wrong API use : tried to return a value of an unknown type (${result}).`, -1);
                    }
                    break;
                default:
                    this.wasm.sqlite3_result_null(sqlite3ContextPtr);
            }
        };
        if (name in this.functions) {
            this.wasm.removeFunction(this.functions[name]);
            delete this.functions[name];
        }
        const funcPtr = this.wasm.addFunction(wrappedFunc, 'viii');
        this.functions[name] = funcPtr;
        this.handleError(this.wasm.sqlite3_create_function_v2(this.dbPtr, name, func.length, sqlite3_types_1.ReturnCode.UTF8, 0, funcPtr, 0, 0, 0));
        return this;
    }
}
exports.default = Database;
//# sourceMappingURL=Database.js.map