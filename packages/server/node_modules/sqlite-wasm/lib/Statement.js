"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sqlite3_types_1 = require("./sqlite3-types");
class Statement {
    constructor(stmt, db) {
        this.wasm = db.wasm;
        this.stmt = stmt;
        this.db = db;
        this.pos = 1;
        this.allocatedmem = [];
    }
    bind(values) {
        const bindFromArray = (values) => {
            values.forEach((value, i) => {
                this.bindValue(value, i + 1);
            });
        };
        const bindFromObject = (valuesObj) => {
            for (const [name, value] of Object.entries(valuesObj)) {
                const num = this.wasm.sqlite3_bind_parameter_index(this.stmt, name);
                if (num !== 0) {
                    this.bindValue(value, num);
                }
            }
        };
        if (!this.stmt) {
            throw new Error('Statement closed');
        }
        this.reset();
        if (Array.isArray(values)) {
            bindFromArray(values);
        }
        else {
            bindFromObject(values);
        }
        return;
    }
    bindValue(val, pos = this.pos++) {
        const bindString = (str, pos = this.pos++) => {
            const bytes = this.wasm.intArrayFromString(str);
            const strPtr = this.wasm.allocate(bytes, 'i8', this.wasm.ALLOC_NORMAL);
            this.allocatedmem.push(strPtr);
            this.db.handleError(this.wasm.sqlite3_bind_text(this.stmt, pos, strPtr, bytes.length - 1, 0));
        };
        const bindBlob = (array, pos = this.pos++) => {
            const blobPtr = this.wasm.allocate(array, 'i8', this.wasm.ALLOC_NORMAL);
            this.allocatedmem.push(blobPtr);
            this.db.handleError(this.wasm.sqlite3_bind_blob(this.stmt, pos, blobPtr, array.length, 0));
        };
        const bindNumber = (num, pos = this.pos++) => {
            const bindfunc = num === (num | 0) ? this.wasm.sqlite3_bind_int : this.wasm.sqlite3_bind_double;
            this.db.handleError(bindfunc(this.stmt, pos, num));
        };
        const bindNull = (pos = this.pos++) => {
            this.db.handleError(this.wasm.sqlite3_bind_blob(this.stmt, pos, 0, 0, 0));
        };
        switch (typeof val) {
            case 'string':
                bindString(val, pos);
                break;
            case 'number':
            case 'boolean':
                bindNumber(val + 0, pos);
                break;
            case 'object':
                if (val === null) {
                    bindNull(pos);
                }
                else if (Array.isArray(val)) {
                    bindBlob(val, pos);
                }
                else {
                    throw new Error(`Wrong API use : tried to bind a value of an unknown type (${val}).`);
                }
                break;
            default:
                throw new Error(`Wrong API use : tried to bind a value of an unknown type (${val}).`);
        }
        return;
    }
    step() {
        if (!this.stmt) {
            throw new Error('Statement closed');
        }
        this.pos = 1;
        const ret = this.wasm.sqlite3_step(this.stmt);
        switch (ret) {
            case sqlite3_types_1.ReturnCode.ROW:
                return true;
            case sqlite3_types_1.ReturnCode.DONE:
                return false;
            default:
                this.db.handleError(ret);
                return false;
        }
    }
    get(params) {
        const getNumber = (pos = this.pos++) => {
            return this.wasm.sqlite3_column_double(this.stmt, pos);
        };
        const getString = (pos = this.pos++) => {
            return this.wasm.sqlite3_column_text(this.stmt, pos);
        };
        const getBlob = (pos = this.pos++) => {
            const ptr = this.wasm.sqlite3_column_blob(this.stmt, pos);
            const size = this.wasm.sqlite3_column_bytes(this.stmt, pos);
            return this.wasm.HEAPU8.subarray(ptr, ptr + size);
        };
        if (typeof params !== 'undefined') {
            this.bind(params);
            this.step();
        }
        const results = [];
        const colSize = this.wasm.sqlite3_data_count(this.stmt);
        for (let col = 0; col < colSize; col++) {
            switch (this.wasm.sqlite3_column_type(this.stmt, col)) {
                case sqlite3_types_1.ReturnCode.INTEGER:
                case sqlite3_types_1.ReturnCode.FLOAT:
                    results.push(getNumber(col));
                    break;
                case sqlite3_types_1.ReturnCode.TEXT:
                    results.push(getString(col));
                    break;
                case sqlite3_types_1.ReturnCode.BLOB:
                    results.push(getBlob(col));
                    break;
                default:
                    results.push(null);
                    break;
            }
        }
        return results;
    }
    getColumnNames() {
        const results = [];
        const colSize = this.wasm.sqlite3_data_count(this.stmt);
        for (let col = 0; col < colSize; col++) {
            results.push(this.wasm.sqlite3_column_name(this.stmt, col));
        }
        return results;
    }
    getAsObject(params) {
        const values = this.get(params);
        const names = this.getColumnNames();
        const rowObject = {};
        names.forEach((name, i) => {
            rowObject[name] = values[i];
        });
        return rowObject;
    }
    run(values) {
        if (typeof values !== 'undefined') {
            this.bind(values);
        }
        this.step();
        return this.reset();
    }
    reset() {
        this.freemem();
        return (this.wasm.sqlite3_clear_bindings(this.stmt) === sqlite3_types_1.ReturnCode.OK &&
            this.wasm.sqlite3_reset(this.stmt) === sqlite3_types_1.ReturnCode.OK);
    }
    freemem() {
        let mem;
        while ((mem = this.allocatedmem.pop())) {
            this.wasm._free(mem);
        }
        return null;
    }
    free() {
        this.freemem();
        const res = this.wasm.sqlite3_finalize(this.stmt) === sqlite3_types_1.ReturnCode.OK;
        delete this.db.statements[this.stmt];
        this.stmt = this.wasm.NULL;
        return res;
    }
}
exports.default = Statement;
//# sourceMappingURL=Statement.js.map