"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
class WorkerWrapper {
    constructor(sqlWorker) {
        this.sqlWorker = sqlWorker;
        this.sqlWorker.onerror = error => {
            const message = (() => {
                if (error instanceof ErrorEvent) {
                    return [
                        `FileName: ${error.filename}`,
                        `LineNumber: ${error.lineno}`,
                        `Message: ${error.message}`,
                    ].join(' - ');
                }
                else {
                    return error;
                }
            })();
            console.error(message);
        };
    }
    static init({ wasmBinary, worker, }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const obj = new WorkerWrapper(worker);
            return new Promise((resolve, reject) => {
                obj.handleMessageFromWorker(response => {
                    if (response.respondTo !== 'init') {
                        reject(new Error('Internal Error: response is not init'));
                        return;
                    }
                    else if (!response.success) {
                        reject(new Error('Internal Error: init failed'));
                        return;
                    }
                    resolve(obj);
                });
                obj.postMessageToWorker({
                    command: 'init',
                    wasmBinary,
                }, [wasmBinary]);
            });
        });
    }
    open({ dbBinary }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this.handleMessageFromWorker(response => {
                    if (response.respondTo !== 'open') {
                        reject(new Error('Internal Error: response is not open'));
                        return;
                    }
                    else if (!response.success) {
                        reject(new Error('Internal Error: open failed'));
                        return;
                    }
                    resolve(this);
                });
                this.postMessageToWorker({
                    command: 'open',
                    dbBinary
                }, [dbBinary]);
            });
        });
    }
    run({ query }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this.handleMessageFromWorker(response => {
                    if (response.respondTo !== 'exec') {
                        reject(new Error('Internal Error: response is not exec'));
                        return;
                    }
                    resolve(response.results);
                });
                this.postMessageToWorker({
                    command: 'exec',
                    sql: query,
                });
            });
        });
    }
    terminate() {
        this.sqlWorker.terminate();
    }
    handleMessageFromWorker(handler) {
        this.sqlWorker.addEventListener('message', event => handler(event.data), { once: true });
    }
    postMessageToWorker(message, transfer = []) {
        this.sqlWorker.postMessage(message, transfer);
    }
}
exports.default = WorkerWrapper;
//# sourceMappingURL=WorkerWrapper.js.map