"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
function initWorker() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const sqlite3Wasm = (yield Promise.resolve().then(() => tslib_1.__importStar(require('./sqlite3-emscripten')))).default;
        const DatabaseWasm = (yield Promise.resolve().then(() => tslib_1.__importStar(require('./Database')))).default;
        const loadWasm = wasmLoader(sqlite3Wasm);
        let db;
        let wasm;
        onmessage = function (e) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const { data } = e;
                switch (data.command) {
                    case 'init': {
                        wasm = (yield loadWasm(data.wasmBinary));
                        postMessage({ respondTo: 'init', success: true });
                        break;
                    }
                    case 'open': {
                        if (db) {
                            db.close();
                        }
                        db = new DatabaseWasm(wasm, new Uint8Array(data.dbBinary));
                        postMessage({ respondTo: 'open', success: true });
                        break;
                    }
                    case 'exec': {
                        if (!db) {
                            throw new Error('exec: DB is not initialized.');
                        }
                        if (!data.sql) {
                            throw new Error('exec: Missing query string');
                        }
                        postMessage({
                            respondTo: 'exec',
                            results: db.exec(data.sql),
                        });
                        break;
                    }
                    case 'each': {
                        if (!db)
                            throw new Error('exec: DB is not initialized.');
                        if (!data.sql)
                            throw new Error('exec: Missing query string');
                        db.each(data.sql, data.params, (row) => postMessage({ respondTo: 'each', row, end: false }), () => postMessage({ respondTo: 'each', row: {}, end: true }));
                        break;
                    }
                    case 'export': {
                        if (!db)
                            throw new Error('exec: DB is not initialized.');
                        const buffer = db.export();
                        postMessage({ respondTo: 'export', buffer }, [buffer]);
                        break;
                    }
                    case 'close': {
                        if (!db)
                            throw new Error('close: DB is not opened yet.');
                        db.close();
                        postMessage({ respondTo: 'close', success: true });
                        break;
                    }
                    default: {
                        throw new Error(`Invalid command: ${data}`);
                    }
                }
            });
        };
    });
}
exports.default = initWorker;
function wasmLoader(wasmModule) {
    let loadedModule = null;
    return function (wasmBinary) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                if (loadedModule) {
                    resolve(loadedModule);
                }
                const moduleOverrides = {};
                moduleOverrides['onAbort'] = function (what) {
                    reject(what);
                };
                moduleOverrides['wasmBinary'] = wasmBinary;
                try {
                    wasmModule(moduleOverrides).then(wasmModule => {
                        delete wasmModule['then'];
                        loadedModule = wasmModule;
                        resolve(wasmModule);
                    });
                }
                catch (e) {
                    reject(new Error(`Loading SQLite .wasm module failed: ${e}`));
                }
            });
        });
    };
}
if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
    initWorker()
        .catch(e => {
        throw new Error(`Worker Error: Failed to load the worker: ${e}`);
    });
}
//# sourceMappingURL=worker.js.map